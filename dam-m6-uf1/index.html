<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="module" src="/sofi/js/script.js"></script>
<link rel="stylesheet" href="/sofi/css/estil.css">

<nav></nav>
<header>
  <h1>DAM - M6 Accés a dades - UF1 Persistència en fitxers</h1>
  <abstract>

  </abstract>
</header>

<section>
    <h2>Path operations</h2>

    <p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html">Paths</a>
    , <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html">Path</a>
    , <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html">Files</a>

    <p>Un objecte de classe <w>Path</w> conté el nom de fitxer i la llista de directoris 
        que s’utilitzen per construir el camí i s’utilitza per examinar, 
        localitzar i manipular fitxers i directoris.</p>

        <p>Per a obtenir un objecte <w>Path</w> utilitza el mètode static <w>Paths.get()</w> </p>
    <sc java>
        Path path = Paths.get("/ruta/al/fitxer/o/directori");
    </sc>

    <p>Exemples</p>
    <sc java>
        // obtenir el nom d'un fitxer, i unir-lo a la ruta d'un altre directori
        Path file = Paths.get("/usr/local/file.txt");
        Path dir = Paths.get("/home/user");

        System.out.println(dir.resolve(file.getFileName()));  //    /home/user/file.txt
    

        // relativitzar una ruta respecte a una altra
        Path file = Paths.get("/a/b/c/d.txt");
        Path dir = Paths.get("/a/b/");

        System.out.println(dir.relativize(file)); //     c/d.txt
    </sc>

    <p>La classe <w>Files</w> conté mètodes estàtics per a fer operacions sobre fitxers i directoris</p>
    
    <sc java>
        // crear un directori i els seus parents
        Files.createDirectories(Paths.get("/some/non/existing/directories"));    

        // Imprimir el contingut d'un directori
        Files.list(Paths.get("/some/directory")).forEach(System.out::println);

        // Obtenir la llista dels continguts niats d'un directori
        List&lt;Path&gt; list = Files.walk(Paths.get("/this/directory")).collect(Collectors.toList());
   
        // Imprimir els fitxers regulars d'un directori ordenats per tamany
        Files.list(Paths.get("/another/directori"))
            .filter(Files::isRegularFile)
            .sorted(Comparator.comparingLong(path -> { try { return Files.size(path); } catch (IOException e) { return 0; }}))
            .forEach(System.out::println);

        // Obtenir l'any, mes i dia de la data d'ultima modificació
        Path file = Paths.get("/one/more/file");

        LocalDateTime time = LocalDateTime.parse(Files.getLastModifiedTime(file).toString(), DateTimeFormatter.ISO_DATE_TIME);

        System.out.println(time.getYear());
        System.out.println(time.getMonthValue());
        System.out.println(time.getDayOfMonth());
    </sc>

    <!--
        https://stackoverflow.com/questions/27644361/how-can-i-throw-checked-exceptions-from-inside-java-8-streams
    -->
</section>

<section>
    <h2>Orientat a bytes</h2>
    <h3>OutputStream / InputStream</h3>
    <p><w>write()</w></p>
    <sc java>
        // escriure bytes a un fitxer
        OutputStream os = Files.newOutputStream(path);
        os.write(63);
        os.write(127);
        os.write(33);
    </sc>

    <p><w>read()</w></p>
    <sc java>
        // llegir un byte d'un fitxer
        InputStream is = Files.newInputStream(path);
        int a = is.read();
    </sc>

    <sc java>
        // llegir tots els bytes un a un
        InputStream is = Files.newInputStream(path);
        for (int a; (a = is.read()) != -1;){
            System.out.println(a);
        }
    </sc>
</section>
<section>
    <h2>Orientat a caracters</h2>
    <h3>UTF-8</h3>

    <table>
        <tr><td colspan="2">First code point</td><td colspan="2">Last code point</td><td>Byte 1</td><td>Byte 2</td><td>Byte 3</td><td>Byte 4</td></tr>
        <tr><td>0000</td><td>0</td><td>007F</td><td>127</td><td>0xxxxxxx</td></tr>
        <tr><td>0080</td><td>128</td><td>07FF</td><td>2047</td><td>110xxxxx</td><td>10xxxxxx</td></tr>
        <tr><td>0800</td><td>2048</td><td>FFFF</td><td>65535</td><td>110xxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr>
        <tr><td>10000</td><td>65536</td><td>10FFFF</td><td>1114111</td><td>110xxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr>
    </table>

    <h3>BufferedWriter / BufferedReader</h3>

    <p><w>write("A")</w>, escriu el codepoint del caracter "A" codificat amb UTF-8.
        <br>
        <w>write(65)</w>, escriu el codepoint 65 codificat en UTF-8</p>

    <sc java>
        // Escriure caracters
        try (BufferedWriter bw = Files.newBufferedWriter(Paths.get("string2.txt"))){
            bw.write("A");
            bw.write(8986);
            bw.write("Java");
            bw.write(new char[]{'T','M'});
        } catch (IOException e) {
            e.printStackTrace();
        }

    </sc>

    <p><w>read()</w></p>
    <sc java>
        // llegir caracters
        try (BufferedReader br = Files.newBufferedReader(Paths.get("file.txt"))){
            char a = (char) br.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    </sc>

    <p><w>readLine()</w></p>
    <sc java>

        // llegir una línia
        try (BufferedReader br = Files.newBufferedReader(Paths.get("file.txt"))){
            String l = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
    </sc>

    <h3>Files.writeString / Files.write / Files.lines</h3>
    <p><w>Files.writeString()</w></p>
    <sc java>
        // escriure un string
        try {
            Files.writeString(Paths.get("string.txt"), "This is a string");
        } catch (IOException e) {
            e.printStackTrace();
        }
         
    </sc>

    <p><w>Files.write()</w></p>
    <sc java>
        // escriure cada String d'una List en una nova línia
        List&lt;String&gt; lines = Arrays.asList("linea1","linea2", "linea3");

        try {
            Files.write(Paths.get("lines.txt"), lines);
        } catch (IOException e) {
            e.printStackTrace();
        }
         
    </sc>

    <p><w>Files.lines()</w></p>
    <sc java>
        // llegir varies linies en un Stream
        try (Stream&lt;String&gt; lines = Files.lines(Paths.get("lines.txt"))) {
            lines.forEach(System.out::println);
        }

        // --- alternativa
        try {
            Files.lines(Paths.get("lines.txt"))
                    .forEach(System.out::println);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // recollir l'Stream en una List
        try {
            List&lt;String&gt; lines = Files.lines(Paths.get("lines.txt")).collect(Collectors.toList());
            
            for(String line : lines) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    </sc>

    <!--
    <h4>DataOutputStream / DataInputStream</h4>
    <ul>
        <li><w>write()</w> escriu l'últim byte d'un enter
        <li><w>writeUTF()</w> als 2 primers bytes guarda la longitud del string (en bytes, no en caracters) i després el string (max 65535)
        <li><w>writeInt()</w> escriu un enter (4 bytes)
        </ul>
    <sc java>
        try (DataOutputStream dos = new DataOutputStream(Files.newOutputStream(Paths.get("bytes.dat")))){
            dos.write(20292);
            dos.writeUTF("Ç");
            dos.writeInt(34);
        }

        try(DataInputStream dis = new DataInputStream(Files.newInputStream(Paths.get("bytes.dat")))) {
            int a = dis.read();
            String b = dis.readUTF();
            int c = dis.readInt();
        }
    </sc>

    <h4>OutputStreamWriter / InputStreamReader</h4>
    <p>Es llegeix/escriu UTF-8. Li hem d'indicar quants caracters volem llegir.</p>
    <sc java>
        try (OutputStreamWriter osw = new OutputStreamWriter(Files.newOutputStream(Paths.get("chars.txt")))){
            osw.write(8986);
            osw.write("Ç");
        }

        try(InputStreamReader isr = new InputStreamReader(new FileInputStream("chars.txt"))) {
            char[] buffer = new char[2];
            isr.read(buffer);
            System.out.println(String.valueOf(buffer));  // ⌚Ç
        }
    </sc>
    -->
</section>

<section>
    <h2>JSON/XML</h2>

    <p>Instal·lar la llibreria <a href="https://github.com/FasterXML/jackson">FasterXML/Jackson</a></p>

    <scfile>build.gradle</scfile>
    <sc groovy>
        plugins {
            id 'java'
        }
        
        sourceSets.main.java.srcDirs = [ "src/" ]
        
        repositories {
            mavenCentral()
        }

        dependencies {
            implementation 'com.fasterxml.jackson.core:jackson-databind:2.13.0'
        }
    </sc>

    <p>JSON d'exemple</p>

    <sc json>
        {
            "nombre": "Juan",
            "ciclo": {
                "titulo": "DAM",
                "curso": 2
            },
            "modulos": [
                { 
                    "codigo": "M6", 
                    "nota": 9.8 
                },
                { 
                    "codigo": "M8", 
                    "nota": 9.9 
                }
            ]
        }
    </sc>

    <p>Mapping classes per al JSON d'exemple</p>
    <sc java>
        class Estudiante {
            public String nombre;
            public CicloFormativo ciclo;
            public List&lt;Modulo&gt; modulos;
        }

        class CicloFormativo {
            public String titulo;
            public int curso;
        }

        class Modulo {
            public String codigo;
            public float nota;
        }
    </sc>

    <h3>JSON &lt;-&gt; String</h3>
    <p><w>readValue(String, Class&lt;T&gt;)</w></p>

    <sc java>
        String jsonValue = "{\"nombre\": \"Juan\", \"ciclo\": { \"titulo\": \"DAM\", \"curso\": 2 }, \"modulos\": [ { \"codigo\": \"M6\", \"nota\": 9.8 }, { \"codigo\": \"M8\", \"nota\": 9.9 } ] }";
        
        ObjectMapper objectMapper = new ObjectMapper();

        Estudiante estudiante = objectMapper.readValue(jsonValue, Estudiante.class);

        <low>
        System.out.println(estudiante.nombre);
        System.out.println(estudiante.ciclo.titulo + estudiante.ciclo.curso);
        System.out.println(estudiante.modulos.stream().map(m -> m.codigo + ": " + m.nota).collect(Collectors.joining("\n")));
        </low>
    </sc>

    <p><w>writeValueAsString(Object)</w></p>
    <sc java>
        <low>
        Estudiante estudiante = new Estudiante();
        estudiante.nombre = "Pepe";
        estudiante.ciclo = new CicloFormativo();
        estudiante.ciclo.titulo = "DAW";
        estudiante.ciclo.curso = 1;
        estudiante.modulos = new ArrayList&lt;&gt;();
        estudiante.modulos.add(new Modulo());
        estudiante.modulos.add(new Modulo());
        estudiante.modulos.get(0).codigo = "M2";
        estudiante.modulos.get(0).nota = 7;
        estudiante.modulos.get(1).codigo = "M3";
        estudiante.modulos.get(1).nota = 8.2f;
        </low>
    
        ObjectMapper objectMapper = new ObjectMapper();

        String jsonValue = objectMapper.writeValueAsString(estudiante);
        
        <low>
        System.out.println(jsonValue);
        </low>
    </sc>

    <h3>JSON &lt;-&gt; File</h3>
    <p><w>readValue(File, Class&lt;T&gt;)</w></p>
    <sc java>
        Estudiante estudiante = objectMapper.readValue(Paths.get("file.json").toFile(), Estudiante.class);
        
        <low>
        System.out.println(estudiante.nombre);
        System.out.println(estudiante.ciclo.titulo + estudiante.ciclo.curso);
        System.out.println(estudiante.modulos.stream().map(m -> m.codigo + ": " + m.nota).collect(Collectors.joining("\n")));
        </low>
    </sc>

    <p><w>writeValue(File, Object)</w></p>
    <sc java>
        <low>
        Estudiante estudiante = new Estudiante();
        estudiante.nombre = "Juan";
        // ...
        </low>
        
        objectMapper.writeValue(Paths.get("file.json").toFile(), estudiante);
    </sc>

    <h3>JSON &lt;-&gt; URL</h3>

    <p><w>readValue(URL, Class&lt;T&gt;</w></p>
    <sc java>
        ObjectMapper objectMapper = new ObjectMapper();

        Estudiante estudiante = objectMapper.readValue(new URL("https://gist.githubusercontent.com/gerardfp/b6b72efb17404d46bfc0a13200166167/raw/4864017a335d66a24e6250faabaeef111ca1ebc7/estudiante.json"), Estudiante.class);

        <low>
        System.out.println(estudiante.nombre);
        System.out.println(estudiante.ciclo.titulo + estudiante.ciclo.curso);
        System.out.println(estudiante.modulos.stream().map(m -> m.codigo + ": " + m.nota).collect(Collectors.joining("\n")));
        </low>
    </sc>
</section>