
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Loops</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="loops"
                  title="Loops"
                  environment="web"
                  feedback-link="https://github.com/gerardfp">
    
      <google-codelab-step label="Introducci√≥" duration="0">
        <p class="image-container"><img style="width: 423.00px" src="img/e1e3bd5028b8da7e.png"></p>
<p>En la programaci√≥ inform√†tica, un bucle √©s una seq√º√®ncia d&#39;instruccions que es repeteix cont√≠nuament fins que s&#39;arriba a una determinada condici√≥. Normalment, es fa un determinat proc√©s, com ara obtenir un element de dades i canviar-lo, i despr√©s es comprova alguna condici√≥, com si un comptador hagi arribat a un nombre prescrit. Si no ho fa, la seg√ºent instrucci√≥ en la seq√º√®ncia √©s una instrucci√≥ per tornar a la primera instrucci√≥ de la seq√º√®ncia i repetir la seq√º√®ncia. Si s&#39;ha arribat a la condici√≥, la seg√ºent instrucci√≥ &#34;cau&#34; a la seg√ºent instrucci√≥ seq√ºencial o branques fora del bucle. Un bucle √©s una idea fonamental de programaci√≥ que s&#39;utilitza habitualment en l&#39;escriptura de programes.</p>
<p>En aquest CodeLab utilitzarem els loops per a crear imatges art√≠stiques i ritmes musicals.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Crea el projecte" duration="0">
        <p>Descarrega Processing de la seva web oficial:</p>
<p><a href="https://processing.org/download/" target="_blank"><paper-button class="colored" raised><iron-icon icon="cloud_download"></iron-icon>Download Processing</paper-button></a></p>
<p>Descomprimeix l&#39;arxiu que has descarregat i executa <sc>Processing</sc>.</p>
<p>S&#39;obrir√† l&#39;entorn de programaci√≥ de Processing. Anomena i desa el projecte amb el nom <sc>Loops</sc></p>
<p class="image-container"><img style="width: 386.00px" src="img/58ab6d8d1f502a6d.png"></p>
<p>Instal¬∑la tamb√© la llibreria Sound. Per fer-ho ves a <sc>Herramientas</sc> &gt; <sc>A√±adir Herramienta...</sc></p>
<p class="image-container"><img style="width: 649.00px" src="img/a5a8a8527f3416a2.png"></p>
<p>Tamb√© necessitar√†s aquests dos sons, descarrega&#39;ls a la carpeta del projecte amb els noms que s&#39;indiquen:</p>
<p><a href="https://freewavesamples.com/files/Korg-N1R-Snare-Drum.wav" target="_blank">https://freewavesamples.com/files/Korg-N1R-Snare-Drum.wav</a> <sc>snare.wav</sc></p>
<p><a href="https://freewavesamples.com/files/Korg-N1R-Bass-Drum.wav" target="_blank">https://freewavesamples.com/files/Korg-N1R-Bass-Drum.wav</a> <sc>bass.wav</sc></p>


      </google-codelab-step>
    
      <google-codelab-step label="Processing API" duration="0">
        <p>Processing proporciona una API amb infinitud de m√®todes a disposici√≥ del programador per a ser usats. En aquest CodeLab utilitzarem aquests:</p>
<table>
<tr><td colspan="1" rowspan="1"><p><sc>size(w, h)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>w: amplada de la finestra</sc></p>
<p><sc>h: al√ßada de la finestra</sc></p>
</td><td colspan="1" rowspan="1"><p>Defineix el tamany de la finestra</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>background(gray)</sc></p>
<p><sc>background(r, g, b)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>gray: gris (0,255)</sc></p>
<p><sc>r: vermell (0-255)</sc></p>
<p><sc>g: verd (0-255)</sc></p>
<p><sc>b: blau (0-255)</sc></p>
</td><td colspan="1" rowspan="1"><p>Defineix el color de fons</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>fill(gray)</sc></p>
<p><sc>fill(r, g, b)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>gray: gris (0,255)</sc></p>
<p><sc>r: vermell (0-255)</sc></p>
<p><sc>g: verd (0-255)</sc></p>
<p><sc>b: blau (0-255)</sc></p>
</td><td colspan="1" rowspan="1"><p>Defineix el color en que s&#39;omplir√†n les figures</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>stroke(gray)</sc></p>
<p><sc>stroke(r, g, b)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>gray: gris (0,255)</sc></p>
<p><sc>r: vermell (0-255)</sc></p>
<p><sc>g: verd (0-255)</sc></p>
<p><sc>b: blau (0-255)</sc></p>
</td><td colspan="1" rowspan="1"><p>Defineix el color en que es dibuixaran les l√≠nies i les vores de les figures</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>strokeWeight(w)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>w: el gruixut del tra√ß</sc></p>
</td><td colspan="1" rowspan="1"><p>Defineix el gruixut en que es dibuixaran les l√≠nies i les vores de les figures</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>circle(x, y, d)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>x: coordinada X</sc></p>
<p><sc>y: coordinada Y</sc></p>
<p><sc>d: di√†metre</sc></p>
</td><td colspan="1" rowspan="1"><p>Dibuixa un circle</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>line(x1, y1, x2, y2)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>x1: coordinada X del punt1</sc></p>
<p><sc>y1: coordinada Y del punt1</sc></p>
<p><sc>x2: coordinada X del punt2</sc></p>
<p><sc>y2: coordinada Y del punt2</sc></p>
</td><td colspan="1" rowspan="1"><p>Dibuixa una l√≠nia</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>point(x, y)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>x: coordinada X</sc></p>
<p><sc>y: coordinada Y</sc></p>
</td><td colspan="1" rowspan="1"><p>Dibuixa un punt</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>rect(x, y, w, h)</sc></p>
<p><sc>rect(x, y, w, h, r)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>x: coordinada X</sc></p>
<p><sc>y: coordinada Y</sc></p>
<p><sc>w: amplada</sc></p>
<p><sc>h: al√ßada</sc></p>
<p><sc>r: radi dels cantons </sc></p>
</td><td colspan="1" rowspan="1"><p>Dibuixa un rectangle</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><sc>triangle(x1, y1, x2, y2, x3, y3)</sc></p>
</td><td colspan="1" rowspan="1"><p><sc>x1: coordinada X del punt1</sc></p>
<p><sc>y1: coordinada Y del punt1</sc></p>
<p><sc>x2: coordinada X del punt2</sc></p>
<p><sc>y2: coordinada Y del punt2</sc></p>
<p><sc>x3: coordinada X del punt3</sc></p>
<p><sc>y4: coordinada Y del punt3</sc></p>
</td><td colspan="1" rowspan="1"><p>Dibuixa un triangle</p>
</td></tr>
</table>
<aside class="special"><p>Trobar√†s tots els m√®todes de la API aqu√≠: <a href="https://processing.org/reference/" target="_blank">https://processing.org/reference/</a></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Dibuixant amb loops" duration="0">
        <p>Comen√ßarem amb els rectangles.</p>
<p>Dibuixar un rectangle √©s molt f√†cil:</p>
<pre><sc>size(300, 200);  // finestra de 300x200
background(0);   // fons negre
stroke(255);     // tra√ß blanc
fill(0, 0);      // figures transparents
strokeWeight(2); // gruixut del tra√ß 2


rect(0, 25, 100, 150);   // el 0 √©s la posici√≥ x
                         // el 25 √©s la posici√≥ y
                         // el 100 √©s l&#39;amplada
                         // el 150 √©s l&#39;al√ßada</sc></pre>
<p class="image-container"><img style="width: 302.00px" src="img/686008d57329f24d.png"></p>
<p>Dibuixar-ne varis tamb√© √©s molt f√†cil. Nom√©s cal copiar la sent√®ncia  v√†ries vegades:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

rect(0, 50, 100, 150);  
rect(10, 50, 100, 150);  
rect(20, 50, 100, 150);  
rect(30, 50, 100, 150);  
rect(40, 50, 100, 150);
rect(50, 50, 100, 150);</sc></pre>
<p class="image-container"><img style="width: 302.00px" src="img/c2aece367bfb2ef9.png"></p>
<p>Observa que al codi anterior, hi ha una sent√®ncia que es repeteix, on nom√©s varia el valor de la posici√≥ <sc>X</sc> del rectangle: <sc>0, 10, 20, 30, 40</sc></p>
<p>Quan tenim un patr√≥ que es repeteix en un programa, on hi nom√©s hi ha petites variacions en cada repetici√≥, aquest patr√≥ √©s subceptible de transformar-lo en un <em>loop</em>.</p>
<p>Hem de detectar en qu√® varia el patr√≥ i substituir all√≤ que varia per una... <strong>variable!</strong></p>
<p><sc>rect(x, 50, 100, 150);  </sc></p>
<p>Ara cal definir quins valors prendr√† aquesta variable en les successives iteracions del <em>loop</em>. √âs a dir, cal definir:</p>
<ul>
<li>Quin valor tindr√† a l&#39;inici ‚Üí  la <sc>x</sc> comen√ßa per <sc>0</sc> (<sc>x=0</sc>)</li>
<li>Quina condici√≥ ha de complir el valor ‚Üí  la <sc>x</sc> √©s sempre menor o igual a <sc>50</sc> (<sc>x&lt;=0</sc>)</li>
<li>Com es modificar√† a cada iteraci√≥ ‚Üí en cada iteraci√≥ la <sc>x</sc> va augmentant en <sc>10</sc> (<sc>x += 10</sc>)</li>
</ul>
<p>Aix√≠ podem construir el bucle <sc>while</sc>:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

int x=0;
while (x &lt;= 50){
  rect(x, 25, 100, 150);    

  x += 10;
}</sc></pre>
<p>En el seg√ºent diagrama de flux podem veure com les dues instruccions que estan dintre del bucle while, es van repetint mentre es compleix la condici√≥ <sc>x&lt;=50</sc></p>
<p class="image-container"><img style="width: 276.00px" src="img/eb91adc1d31866c8.png"></p>
<p>Com dintre del bucle anem canviant el valor de la variable <sc>x</sc>, cada cop el rectangle es dibuix a en una posici√≥ diferent.</p>
<p>D&#39;aquesta manera, en lloc d&#39;especificar uns valors fixes per a dibuixar un rectangle, podem fer-ho amb valors canviants i dibuixar cada cop un rectangle diferent en posici√≥ i tamany.</p>
<p>Al seg√ºent exemple canviem els par√†metres posici√≥X, posici√≥Y, amplada i al√ßada, en funci√≥ de la variable <sc>x</sc>:</p>
<p>Aquest cop utilitzarem un bucle for, que √©s equivalent al while per√≤ amb menys l√≠nies:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

for (int x=0; x &lt;= 50; x += 10){
   rect(x, x, x, x);  
}</sc></pre>
<p class="image-container"><img style="width: 302.00px" src="img/293d0364cfc06720.png"></p>
<p>Aquest √©s el diagrama que explica el funcionament de l&#39;algorisme anterior.</p>
<p class="image-container"><img style="width: 276.00px" src="img/e99178f15cb3c644.png"></p>
<p>Com usem la variable <sc>x</sc> per a especificar tant la posicioX com la posici√≥Y, com l&#39;amplada i l&#39;al√ßada, cada cop es dibuixa un rectangle m√©s a la dreta, m√©s avall, i m√©s gran.</p>
<p>Observa que els bucles <sc>while</sc> i <sc>for</sc> s√≥n equivalents. De fet, el bucle <sc>for</sc> √©s una forma m√©s concisa (amb una sola l√≠nia) del bucle <sc>while</sc>.</p>
<p class="image-container"><img style="width: 607.00px" src="img/74a25e4b2b9e6a3e.png"></p>
<p>No sempre √©s f√†cil (o incl√∫s possible) trobar el patr√≥ que segueixen els valors, i aix√≤ impossibilita poder usar un <em>loop</em>. Per exemple a la seg√ºent composici√≥ es fa dif√≠cil trobar un patro com√∫ als valors:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);
rect(30, 19, 33, 36);  
rect(10, 47, 55, 97);  
rect(17, 14, 37, 59);  
rect(123, 91, 13, 49);  
rect(80, 72, 48, 71);  
rect(97, 171, 67, 3);  
rect(41, 112, 138, 7);  </sc></pre>
<p class="image-container"><img style="width: 302.00px" src="img/80939f60328df3d0.png"></p>
<p>Hi ha voltes que podem trobar patrons en els quals alguns valors es deriven d&#39;altres valors:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

rect(0, 0, 0, 0);  
rect(10, 20, 15, 5);  
rect(20, 40, 25, 10);  
rect(30, 60, 35, 15);  
rect(40, 80, 45, 20);   
rect(50, 100, 55, 25); 
rect(60, 120, 65, 30); 
rect(70, 140, 75, 35); </sc></pre>
<p class="image-container"><img style="width: 302.00px" src="img/39ad06ab4818cd65.png"></p>
<p>En aquest cas podem observar:</p>
<ul>
<li>La posici√≥ <sc>x</sc> va augmentant de <sc>10</sc> en <sc>10</sc></li>
<li>La posici√≥ <sc>y</sc> √©s el doble que la posici√≥ <sc>x</sc></li>
<li>L&#39;<sc>amplada</sc> √©s la posici√≥ <sc>x</sc> m√©s <sc>5</sc></li>
<li>L&#39;<sc>al√ßa</sc>da √©s la mitat de la posici√≥ <sc>x</sc></li>
</ul>
<p>De forma que podem transformar aquestes l√≠nies en un <em>loop</em>, amb els valors calculats a partir de la <sc>x</sc> (o qualsevol altre):</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

for (int x=0; x&lt;=70; x += 10){
  rect(x, x*2, x+5, x/2);  
}</sc></pre>
<p>Al seg√ºent dibuix podem trobar un patr√≥ entre la posici√≥X  i l&#39;<sc>amplada</sc> dels rectangles:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

rect(0,0,0,25);
rect(1,0,1,25);
rect(4,0,2,25);
rect(9,0,3,25);
rect(16,0,4,25);
rect(25,0,5,25);
rect(36,0,6,25);
rect(49,0,7,25);
rect(64,0,8,25);
rect(81,0,9,25);
rect(100,0,10,25);</sc></pre>
<p>El patr√≥ √©s, efectivament, que la posici√≥ √©s el quadrat de l&#39;amplada:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

for (int i=0; i&lt;11; i++){
 rect(i*i, 0, i, 25);
}</sc></pre>
<p class="image-container"><img style="width: 302.00px" src="img/1cb9a8196dacc70.png"></p>
<h2 is-upgraded>Doble loops</h2>
<p>En alguns casos ens trobem que alguns valors segueixen un patr√≥, i altres valors en segueixen un altre de diferent. Veiem un exemple.</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

rect(0,0,25,25);
rect(50,0,25,25);
rect(100,0,25,25);
rect(150,0,25,25);

rect(0,50,25,25);
rect(50,50,25,25);
rect(100,50,25,25);
rect(150,50,25,25);

rect(0,100,25,25);
rect(50,100,25,25);
rect(100,100,25,25);
rect(150,100,25,25);

rect(0,150,25,25);
rect(50,150,25,25);
rect(100,150,25,25);
rect(150,150,25,25);</sc></pre>
<p>Aquest codi genera el seg√ºent dibuix:</p>
<p class="image-container"><img style="width: 302.00px" src="img/5674cec6af129b2d.png"></p>
<p>Podem trobar un patr√≥ en els valors que passem a la funci√≥ <sc>rect()</sc>? Observem tres claus:</p>
<ul>
<li>El valor de l&#39;al√ßada i l&#39;amplada √©s sempre <sc>25</sc> (no varia)</li>
<li>El valor de la posici√≥Y va sumant <sc>50</sc> cada quatre instruccions</li>
<li>El valor de la posici√≥X va sumant <sc>50</sc> cada instrucci√≥, per√≤ torna a comen√ßar per 0 cada quatre instruccions</li>
</ul>
<p>Ignorem l&#39;al√ßada i l&#39;amplada, ja que sempre √©s <sc>25</sc> i no varia.</p>
<p>Podem trobar una relaci√≥ entre la posici√≥X i la posici√≥Y? En aquest cas no, no hi ha cap relaci√≥. Els valors s√≥n independents un de l&#39;altre i no es pot calcular un a partir de l&#39;altre. Aleshores, qu√® podem fer?</p>
<p>Tractem de traure primer un patr√≥ i despr√©s veurem que fem amb l&#39;altre. El m√©s senzill de traure, en principi, √©s el de la posici√≥Y, ja que va sumant cada quatre instruccions, per√≤ no torna a comen√ßar com el de la posici√≥X.</p>
<p>Programem aix√≠ el patr√≥ que segueix la posici√≥Y:</p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

for(int y=0; y&lt;=150; y+=50){
  rect(0,y,25,25);
  rect(50,y,25,25);
  rect(100,y,25,25);
  rect(150,y,25,25);
}</sc></pre>
<p>Ara √©s m√©s f√†cil veure el patr√≥ de la posici√≥X. Podem substituir les quatre instruccions que hi ha dintre del <em>loop</em>, per un altre <em>loop</em>:</p>
<p class="image-container"><img style="width: 596.00px" src="img/761ca8a75bcca96b.png"></p>
<pre><sc>size(300, 200); background(0); stroke(255); fill(0,0); strokeWeight(2);

for(int y=0; y&lt;=150; y+=50){
  for (int x=0; x&lt;=150; x+=50){
    rect(x,y,25,25);
  }
}</sc></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Ritmes amb loops" duration="0">
        <p>Assegura&#39;t d&#39;haver instal¬∑lat la llibreria <sc>sound</sc> i que has descarregat els sons <sc>snare.wav</sc> i <sc>bass.wav</sc></p>
<p>Reproduir sons amb aquesta llibreria √©s molt f√†cil. Nom√©s cal carregar els sons i donar-li a <sc>play()</sc>. Podem jugar amb el <sc>delay()</sc> per a crear el ritme:</p>
<pre><sc>import processing.sound.*;   // carreguem la llibreria sound

SoundFile snare = new SoundFile(this, &#34;snare.wav&#34;);
SoundFile bass = new SoundFile(this, &#34;bass.wav&#34;);
delay(1000); // donem temps per a carregar els sons


bass.play();
delay(400);
bass.play();
delay(400);
snare.play();
delay(800);

bass.play();
delay(400);
bass.play();
delay(400);
snare.play();
delay(800);

bass.play();
delay(400);
bass.play();
delay(400);
snare.play();
delay(800);</sc></pre>
<p>We will, we will rock you </p>
<p class="image-container"><img style="width: 561.00px" src="img/794d391da1e92ac2.png"></p>
<p>Aqu√≠ podem observar un patr√≥ que es va repetint. Fem un loop:</p>
<pre><sc>// Posa aqu√≠ el codi d&#39;inicialitzaci√≥

for (int i=0; i&lt;3; i++){
  bass.play();
  delay(400);
  bass.play();
  delay(400);
  snare.play();
  delay(800);  
}</sc></pre>
<p class="image-container"><img style="width: 435.00px" src="img/4e68d18ca3abcf81.png"></p>
<p class="image-container"><img style="width: 221.00px" src="img/f85bc3b5764ed16.png"></p>
<p>Amb un <em>loop</em>, hem repetit 3 cops les mateixes instruccions.</p>
<p>Podr√≠em repetir aquest <em>loop</em> durant tota la can√ß√≥, per√≤ quedaria una mica mon√≤tona... Cal posar un redoble:</p>
<pre><sc>for (int j=0; j&lt;3; j++){
  bass.play(); delay(400);
  bass.play(); delay(400);
  snare.play(); delay(800);  
}

bass.play(); delay(400);
bass.play(); delay(400);
snare.play(); delay(200);  
snare.play(); delay(200);  
snare.play(); delay(200); 
snare.play(); delay(200); </sc></pre>
<p class="image-container"><img style="width: 579.00px" src="img/1e769a0446ab386e.png"></p>
<p class="image-container"><img style="width: 221.00px" src="img/11b3bc29f335a084.png"></p>
<p>Observa que el l&#39;√∫ltim bloc (morat) √©s diferent als tres anteriors (taronja), no els podem incloure al mateix <em>loop</em>, ja que no segueixen el mateix patr√≥. Repetim tres cops el patr√≥ taronja i un cop el patr√≥ morat.</p>
<p>Podem encara filar m√©s prim i tractar d&#39;extraure m√©s patrons (coses que es repeteixen), per exemple els quatre <em>snares</em> del final:</p>
<p class="image-container"><img style="width: 579.00px" src="img/ffb9fd410c04428d.png"></p>
<p class="image-container"><img style="width: 223.00px" src="img/598fd1e48cdd0913.png"></p>
<p>Anem a completar seguir una mica la can√ß√≤ fent que tot aquest patr√≥ es repeteixi dues vegades:</p>
<p class="image-container"><img style="width: 736.40px" src="img/d9786df0b7955523.png"></p>
<p class="image-container"><img style="width: 243.00px" src="img/7d1948551608ab21.png"></p>
<p>I aix√≠ podriem seguir fins completar la canc√≥ fent <em>loops </em>dintre de <em>loops</em>... Per√≤ abans d&#39;acabar encara ens queda un petit patr√≥ en el codi:</p>
<p class="image-container"><img style="width: 736.40px" src="img/78b9d98b735eb98e.png"></p>
<p class="image-container"><img style="width: 248.00px" src="img/a79562d637a9a085.png"></p>
<p>I d&#39;aquesta forma, utilitzant <em>loops</em>, hem passat 30 cops de bateria a 9 instruccions de codi üëå</p>


      </google-codelab-step>
    
      <google-codelab-step label="Loop art" duration="0">
        <p>A la web <a href="https://www.openprocessing.org/" target="_blank">https://www.openprocessing.org</a> trobar√†s molt√≠ssimes obres d&#39;art realitzades amb Processing. Aqu√≠ et poso algunes m√©s b√†siques per que puguis estudiar-les.</p>
<pre><sc>size(200, 200);

for(int i=0; i&lt;height; i+=10){
  for(int j=0; j&lt;width; j+=10){
     fill(random(255), random(255), random(255));
     stroke(random(255));
     rect(j, i, 10, 10);
  }
}</sc></pre>
<p class="image-container"><img style="width: 202.00px" src="img/a0b840d6282547f0.png"></p>
<pre><sc>size(200, 200);

for(int i=0; i&lt;height; i+=10){
  for(int j=0; j&lt;width; j+=10){
     fill(random(255), random(255), random(255));
     stroke(random(255));
     triangle(j, i, j+5, i-10, j+10, i);
  }
}</sc></pre>
<p class="image-container"><img style="width: 202.00px" src="img/7a39c7813e7a3e89.png"></p>
<pre><sc>size(200, 200);

for(int i=0; i&lt;height; i+=10){
  for(int j=0; j&lt;width; j+=10){
     fill(random(255), random(255), random(255));
     stroke(random(255));
     circle(j, i, 10);
  }
}</sc></pre>
<p class="image-container"><img style="width: 202.00px" src="img/6a1ad7e2e1fc3861.png"></p>
<pre><sc>for(int i=0; i&lt;height; i+=10){
  for(int j=0; j&lt;width; j+=10){
     stroke(random(255), random(255), random(255));
     line(j, i, width, height);
     stroke(random(255), random(255), random(255));
     line(0, 0, j, i);
     stroke(random(255), random(255), random(255));
     line(0, height, j, i);
     stroke(random(255), random(255), random(255));
     line(width,0, j, i);
  }
}</sc></pre>
<p class="image-container"><img style="width: 202.00px" src="img/284cf7bfa6025f1e.png"></p>
<pre><sc>for (int i=0; i&lt;height; i += 20){
  for (int j=0; j&lt;width; j += 20){
    fill(random(255), random(255), random(255));
    triangle(j, i, i, j, 20, 20); 
  }
}</sc></pre>
<p class="image-container"><img style="width: 402.00px" src="img/7eecb927619c1940.png"></p>
<pre><sc>size(305, 375);

stroke(0);
strokeWeight(10);

fill(255);
rect(5, 5, 75, 81);
rect(5, 95, 75, 190);
rect(80, 180, 170, 190);
rect(250, 270, 50, 40);

fill(#ca4b2a);
rect(80, 5, 220, 265);

fill(#125093);
rect(5, 270, 75, 100);

fill(#fcea93);
rect(250, 310, 50, 60);</sc></pre>
<p class="image-container"><img style="width: 307.00px" src="img/ebe999211fc0eb66.png"></p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
